<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>2-Player Shooter — Mini Dashboard Game</title>
<style>
  :root{
    --bg1:#0f1724; --bg2:#0b2947; --panel: rgba(255,255,255,0.06);
    --p1:#ff4d4d; --p2:#4da6ff; --heal:#7CFC00;
  }
  html,body{height:100%;margin:0;background:linear-gradient(160deg,var(--bg1),var(--bg2));font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial;}
  .wrap{
    display:flex;flex-direction:column;align-items:center;gap:12px;padding:16px;
  }
  header{width:100%;max-width:1080px;color:#fff;text-align:center;}
  header h1{margin:0;font-size:1.4rem;letter-spacing:0.6px}
  .topbar{width:100%;max-width:1080px;display:flex;justify-content:space-between;gap:8px;align-items:center;}
  .panel{background:var(--panel);padding:10px;border-radius:12px;color:#fff;display:flex;gap:12px;align-items:center}
  .board{display:flex;flex-direction:column;gap:6px;}
  .stat{font-size:0.9rem}
  .controls{font-size:0.8rem;opacity:0.9}
  #gameArea{
    width:100%;max-width:1080px;height:640px;border-radius:14px;overflow:hidden;position:relative;
    box-shadow:0 10px 30px rgba(2,6,23,0.7), inset 0 1px 0 rgba(255,255,255,0.03);
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  }
  canvas{display:block;width:100%;height:100%;background:transparent;}
  .overlay{
    position:absolute;left:12px;top:12px;z-index:10;color:#fff;pointer-events:none;
  }
  .centerBanner{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:11;
    padding:18px 26px;border-radius:14px;background:rgba(0,0,0,0.5);backdrop-filter:blur(4px);text-align:center;display:none;
  }
  .centerBanner.show{display:block;}
  .centerBanner h2{margin:0 0 8px 0}
  .btn{background:#fff;color:#111;border:none;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  footer{width:100%;max-width:1080px;text-align:center;color:rgba(255,255,255,0.75);font-size:0.85rem;margin-top:8px}
  @media(max-width:700px){
    #gameArea{height:520px}
    header h1{font-size:1.1rem}
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Two-Player Shooter — Local Multiplayer (WASD + Arrows)</h1>
    <p style="opacity:0.85;margin:6px 0 0 0;font-size:0.85rem">Collect heals, dodge asteroids, shoot the other player. First to 5 kills wins.</p>
  </header>

  <div class="topbar">
    <div class="panel board">
      <div class="stat">Player 1 — <strong id="p1kills">Kills: 0</strong> &nbsp;|&nbsp; HP: <span id="p1hp">100</span></div>
      <div class="controls">W/A/S/D to move · F to shoot · G to heal (if collected)</div>
    </div>

    <div class="panel board" style="margin-left:auto">
      <div class="stat">Player 2 — <strong id="p2kills">Kills: 0</strong> &nbsp;|&nbsp; HP: <span id="p2hp">100</span></div>
      <div class="controls">Arrows to move · L to shoot · ; to heal (if collected)</div>
    </div>

    <div class="panel" style="margin-left:12px">
      <div style="display:flex;flex-direction:column;align-items:flex-end;gap:6px">
        <div style="font-size:0.9rem">Round: <span id="round">1</span></div>
        <div><button id="restartBtn" class="btn">Restart</button></div>
      </div>
    </div>
  </div>

  <div id="gameArea">
    <canvas id="game"></canvas>
    <div class="overlay">
      <div style="margin-bottom:8px">Scoreboard: <span id="scoreBoard">0 - 0</span></div>
      <div style="font-size:0.85rem;opacity:0.9">Press <strong>P</strong> to Pause / Resume</div>
    </div>

    <div id="center" class="centerBanner">
      <h2 id="centerTitle">Get Ready</h2>
      <div id="centerText" style="opacity:0.9;font-size:0.95rem">Play safely — controls shown above.</div>
      <div style="margin-top:10px"><button id="startBtn" class="btn">Start Game</button></div>
    </div>
  </div>

  <footer>Made with Canvas • Avoid running on very old browsers</footer>
</div>

<script>
/* ------------------------------
  2-Player Shooter — single file
   - Canvas based
   - Basic physics, bullets, pickups, obstacles
   - Health, heals, scoring, restart, pause
-------------------------------*/
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: true });

  // Resize canvas to element size (pixel ratio aware)
  function resize() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize);
  // call once after layout
  resize();

  // DOM elements
  const p1hpEl = document.getElementById('p1hp');
  const p2hpEl = document.getElementById('p2hp');
  const p1killsEl = document.getElementById('p1kills');
  const p2killsEl = document.getElementById('p2kills');
  const scoreBoardEl = document.getElementById('scoreBoard');
  const center = document.getElementById('center');
  const centerTitle = document.getElementById('centerTitle');
  const centerText = document.getElementById('centerText');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const roundEl = document.getElementById('round');

  // Game state
  let state = {
    running: false,
    paused: false,
    round: 1,
    maxKillsToWin: 5,
  };

  // Utility
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function rand(min,max){ return Math.random() * (max-min) + min; }
  function now(){ return Date.now(); }

  // Simple beep sound generator using WebAudio
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function beep(freq=440, time=0.07, type='sine', vol=0.08){
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + time);
  }

  // Entities
  const game = {
    width: () => canvas.getBoundingClientRect().width,
    height: () => canvas.getBoundingClientRect().height,
  };

  class Player {
    constructor(x,y, color, controls){
      this.x = x; this.y = y; this.r = 18;
      this.color = color;
      this.speed = 220; // px/sec
      this.health = 100;
      this.maxHealth = 100;
      this.kills = 0;
      this.cooldown = 0; // shoot cooldown
      this.controls = controls;
      this.hasHealPickup = false;
      this.lastHitAt = 0;
      this.invincibleFor = 800; // ms after spawn/hit
    }
    takeDamage(d, hitter){
      const t = now();
      if (t - this.lastHitAt < this.invincibleFor) return false;
      this.health -= d;
      this.lastHitAt = t;
      if (this.health <= 0){
        this.health = 0;
        // death handled externally: respawn, assign kill
        return true;
      }
      return false;
    }
    heal(amount){
      this.health = clamp(this.health + amount, 0, this.maxHealth);
    }
    update(dt, input){
      // Movement
      let vx=0, vy=0;
      if (input[this.controls.up]) vy -= 1;
      if (input[this.controls.down]) vy += 1;
      if (input[this.controls.left]) vx -= 1;
      if (input[this.controls.right]) vx += 1;
      if (vx !== 0 || vy !== 0){
        const len = Math.hypot(vx,vy) || 1;
        vx /= len; vy /= len;
        this.x += vx * this.speed * dt;
        this.y += vy * this.speed * dt;
      }
      // bound
      this.x = clamp(this.x, this.r+6, game.width() - (this.r+6));
      this.y = clamp(this.y, this.r+6, game.height() - (this.r+6));
      // cooldown
      this.cooldown = Math.max(0, this.cooldown - dt);
    }
    canShoot(){ return this.cooldown <= 0; }
    shoot(targetX, targetY){
      if (!this.canShoot()) return null;
      const angle = Math.atan2(targetY - this.y, targetX - this.x);
      const speed = 520;
      this.cooldown = 0.32; // seconds
      const b = new Bullet(this.x, this.y, angle, speed, this);
      return b;
    }
    draw(ctx){
      // draw body
      ctx.save();
      // flicker if recently hit
      const t = now();
      const alpha = (t - this.lastHitAt < this.invincibleFor) ? 0.6 : 1;
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.strokeStyle = 'rgba(0,0,0,0.3)';
      ctx.lineWidth = 2;
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill(); ctx.stroke();
      // face/eye for orientation: simple pupil towards right (just style)
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.beginPath();
      ctx.arc(this.x + this.r*0.25, this.y - this.r*0.35, 4, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      // HP bar
      const w = 56, h = 8;
      const hx = this.x - w/2, hy = this.y - this.r - 14;
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(hx-1, hy-1, w+2, h+2);
      ctx.fillStyle = '#333';
      ctx.fillRect(hx, hy, w, h);
      ctx.fillStyle = '#0f0';
      ctx.fillRect(hx, hy, w * (this.health / this.maxHealth), h);
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.strokeRect(hx, hy, w, h);
      ctx.restore();
      // Heal icon if has
      if (this.hasHealPickup){
        ctx.save();
        ctx.fillStyle = '#fff';
        ctx.font = '600 12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('♥', this.x + this.r + 12, this.y + 4);
        ctx.restore();
      }
    }
  }

  class Bullet {
    constructor(x,y,angle,speed,owner){
      this.x = x; this.y = y; this.vx = Math.cos(angle)*speed; this.vy = Math.sin(angle)*speed;
      this.r = 5; this.owner = owner; this.life = 2.1; // seconds
      this.damage = 18;
    }
    update(dt){
      this.x += this.vx*dt;
      this.y += this.vy*dt;
      this.life -= dt;
    }
    draw(ctx){
      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = '#fff';
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    isOutOfBounds(w,h){
      return (this.x < -20 || this.x > w+20 || this.y < -20 || this.y > h+20 || this.life <= 0);
    }
  }

  class HealPickup {
    constructor(x,y){
      this.x = x; this.y = y;
      this.r = 12;
      this.duration = 14; // seconds before vanish
      this.amount = 40;
      this.spawnAt = now();
    }
    update(dt){ this.duration -= dt; }
    draw(ctx){
      ctx.save();
      // pulsing
      const t = (now()%1000)/1000;
      const scale = 1 + 0.06*Math.sin(t*Math.PI*2);
      ctx.translate(this.x, this.y);
      ctx.scale(scale, scale);
      ctx.beginPath();
      ctx.fillStyle = 'rgba(124,252,0,0.95)';
      ctx.arc(0,0,this.r,0,Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#063';
      ctx.font = 'bold 12px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('+', 0, -1);
      ctx.restore();
    }
  }

  class Asteroid {
    constructor(x,y,vx,vy,r){
      this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.r=r;
    }
    update(dt){
      this.x += this.vx*dt;
      this.y += this.vy*dt;
      // wrap edges
      const w=game.width(), h=game.height();
      if (this.x < -this.r) this.x = w + this.r;
      if (this.x > w + this.r) this.x = -this.r;
      if (this.y < -this.r) this.y = h + this.r;
      if (this.y > h + this.r) this.y = -this.r;
    }
    draw(ctx){
      ctx.save();
      ctx.translate(this.x,this.y);
      ctx.beginPath();
      ctx.fillStyle = 'rgba(180,180,180,0.12)';
      ctx.arc(0,0,this.r,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  // Input handling
  const input = {};
  const mouse = { x: 0, y: 0, down:false };
  window.addEventListener('keydown', e => input[e.key.toLowerCase()] = true);
  window.addEventListener('keyup', e => input[e.key.toLowerCase()] = false);
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    mouse.x = (e.clientX - rect.left);
    mouse.y = (e.clientY - rect.top);
  });
  canvas.addEventListener('mousedown', () => mouse.down = true);
  canvas.addEventListener('mouseup', () => mouse.down = false);

  // Create players
  let p1, p2;
  function spawnPlayers() {
    const w = game.width(), h = game.height();
    p1 = new Player(90, h/2, 'rgba(255,77,77,1)', {up:'w',down:'s',left:'a',right:'d',shoot:'f',heal:'g'});
    p2 = new Player(w-90, h/2, 'rgba(77,166,255,1)', {up:'arrowup',down:'arrowdown',left:'arrowleft',right:'arrowright',shoot:'l',heal:';'});
    // small spawn invincibility
    p1.lastHitAt = now();
    p2.lastHitAt = now();
  }

  // Objects containers
  let bullets = [], healPickups = [], asteroids = [];

  // Spawn asteroids
  function spawnAsteroids(count=4){
    asteroids = [];
    for (let i=0;i<count;i++){
      const x = rand(40, game.width()-40);
      const y = rand(40, game.height()-40);
      const angle = rand(0, Math.PI*2);
      const speed = rand(30,120);
      const r = rand(18,48);
      asteroids.push(new Asteroid(x,y,Math.cos(angle)*speed, Math.sin(angle)*speed, r));
    }
  }

  // Spawn random heal pickup (periodic)
  let nextHealAt = now() + 6000;
  function maybeSpawnHeal(){
    const t = now();
    if (t > nextHealAt){
      nextHealAt = t + rand(9000, 16000);
      // place away from players
      let x,y,tries=0;
      do {
        x = rand(50, game.width()-50);
        y = rand(50, game.height()-50);
        tries++;
      } while ((Math.hypot(x-p1.x,y-p1.y) < 120 || Math.hypot(x-p2.x,y-p2.y) < 120) && tries < 15);
      healPickups.push(new HealPickup(x,y));
    }
  }

  // Shooting controls: map keys to players
  function handleShooting(dt){
    // Player 1 shoot direction toward mouse if mouse used else toward other player
    if (input[p1.controls.shoot]){
      // aim at mouse if moved recently, otherwise aim at p2
      const targetX = mouse.x || p2.x, targetY = mouse.y || p2.y;
      if (p1.canShoot()){
        const b = p1.shoot(targetX, targetY);
        if (b) bullets.push(b), beep(800,0.05,'sine',0.05);
      }
    }
    if (input[p2.controls.shoot]){
      const targetX = p1.x, targetY = p1.y;
      if (p2.canShoot()){
        const b = p2.shoot(targetX, targetY);
        if (b) bullets.push(b), beep(520,0.05,'sine',0.05);
      }
    }
    // Heal usage (consume pickup)
    if (input[p1.controls.heal] && p1.hasHealPickup){
      p1.heal(40);
      p1.hasHealPickup = false;
      input[p1.controls.heal] = false; // single use
      beep(1000,0.07,'triangle',0.06);
    }
    if (input[p2.controls.heal] && p2.hasHealPickup){
      p2.heal(40);
      p2.hasHealPickup = false;
      input[p2.controls.heal] = false;
      beep(1000,0.07,'triangle',0.06);
    }
  }

  // Collision helpers
  function circleHit(a,b){
    const dx = a.x - b.x, dy = a.y - b.y;
    const r = (a.r || 0) + (b.r || 0);
    return dx*dx + dy*dy <= r*r;
  }

  // Respawn a player after death
  function respawn(player, side){
    // side: 'left' or 'right'
    const w = game.width(), h = game.height();
    player.x = side === 'left' ? 90 : w - 90;
    player.y = h/2;
    player.health = player.maxHealth;
    player.lastHitAt = now();
    player.hasHealPickup = false;
  }

  // Winner check
  function checkWinner(){
    if (p1.kills >= state.maxKillsToWin || p2.kills >= state.maxKillsToWin){
      state.running = false;
      const winner = p1.kills > p2.kills ? 'Player 1' : 'Player 2';
      showCenter(`${winner} Wins!`, `Final score: ${p1.kills} - ${p2.kills}`, true);
      beep(400,0.25,'sine',0.12);
    }
  }

  // Drawing background animation (parallax stars and gradient)
  const stars = [];
  function makeStars(n=80){
    stars.length = 0;
    for (let i=0;i<n;i++){
      stars.push({
        x: rand(0, game.width()),
        y: rand(0, game.height()),
        r: rand(0.4, 2.2),
        speed: rand(6, 36),
        alpha: rand(0.2,0.9)
      });
    }
  }
  function drawBackground(dt){
    // gradient overlay (subtle moving)
    const g = ctx.createLinearGradient(0,0,canvas.width,canvas.height);
    const t = (now()/1000) % 10;
    g.addColorStop(0, `rgba(6,18,34,0.15)`);
    g.addColorStop(1, `rgba(10,24,44,0.12)`);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,game.width(),game.height());
    // stars
    for (const s of stars){
      s.x += s.speed * (dt*0.02);
      if (s.x > game.width()+10) s.x = -10;
      ctx.beginPath();
      ctx.fillStyle = `rgba(255,255,255,${s.alpha})`;
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // Game loop variables
  let lastTime = null;
  let accum = 0;

  function gameTick(ts){
    if (!lastTime) lastTime = ts;
    const dt = Math.min((ts - lastTime) / 1000, 0.06); // cap dt
    lastTime = ts;
    if (!state.paused && state.running){
      update(dt);
      render(dt);
    } else {
      // still render the background and players lightly when paused
      render(dt, true);
    }
    requestAnimationFrame(gameTick);
  }

  function update(dt){
    // update players
    p1.update(dt, input);
    p2.update(dt, input);

    // shooting
    handleShooting(dt);

    // update bullets
    for (let i = bullets.length-1; i >=0; i--){
      const b = bullets[i];
      b.update(dt);
      // collisions with players (not with owner)
      if (b.owner !== p1 && circleHit(b, p1)){
        // hit p1
        const died = p1.takeDamage(b.damage, b.owner);
        bullets.splice(i,1);
        if (died){
          // award kill to owner
          b.owner.kills++;
          if (b.owner === p1) p1killsEl.textContent = `Kills: ${p1.kills}`;
          if (b.owner === p2) p2killsEl.textContent = `Kills: ${p2.kills}`;
          // respawn dead
          const side = (p1 === b.owner) ? 'right' : 'left';
          respawn(p1, side);
          // reset coords slightly
          beep(120,0.14,'sine',0.08);
          scoreBoardEl.textContent = `${p1.kills} - ${p2.kills}`;
          checkWinner();
        } else {
          beep(220,0.06,'sine',0.06);
        }
        continue;
      }
      if (b.owner !== p2 && circleHit(b, p2)){
        // hit p2
        const died = p2.takeDamage(b.damage, b.owner);
        bullets.splice(i,1);
        if (died){
          b.owner.kills++;
          if (b.owner === p1) p1killsEl.textContent = `Kills: ${p1.kills}`;
          if (b.owner === p2) p2killsEl.textContent = `Kills: ${p2.kills}`;
          const side = (p2 === b.owner) ? 'right' : 'left';
          respawn(p2, side);
          beep(120,0.14,'sine',0.08);
          scoreBoardEl.textContent = `${p1.kills} - ${p2.kills}`;
          checkWinner();
        } else {
          beep(220,0.06,'sine',0.06);
        }
        continue;
      }
      // collision with asteroids
      let removed = false;
      for (const a of asteroids){
        if (circleHit(b, a)){
          bullets.splice(i,1); removed = true; break;
        }
      }
      if (removed) continue;
      // remove out of bounds
      if (b.isOutOfBounds(game.width(), game.height())) bullets.splice(i,1);
    }

    // pickups
    for (let i = healPickups.length-1; i>=0; i--){
      const hp = healPickups[i];
      hp.update(dt);
      if (circleHit(hp, p1)){
        p1.hasHealPickup = true;
        healPickups.splice(i,1);
        beep(1100,0.06,'sine',0.06);
        continue;
      }
      if (circleHit(hp, p2)){
        p2.hasHealPickup = true;
        healPickups.splice(i,1);
        beep(1100,0.06,'sine',0.06);
        continue;
      }
      if (hp.duration <= 0) healPickups.splice(i,1);
    }

    // asteroids update and collisions with players
    for (const a of asteroids){
      a.update(dt);
      if (circleHit(a, p1)){
        const died = p1.takeDamage(14);
        if (died){ // if died by asteroid, award no kill, respawn
          respawn(p1,'left');
          beep(120,0.14,'sine',0.08);
        } else beep(220,0.05,'sine',0.05);
      }
      if (circleHit(a, p2)){
        const died = p2.takeDamage(14);
        if (died){
          respawn(p2,'right');
          beep(120,0.14,'sine',0.08);
        } else beep(220,0.05,'sine',0.05);
      }
    }

    // spawn heals
    maybeSpawnHeal();
  }

  function render(dt, minimal=false){
    // clear
    ctx.clearRect(0,0,game.width(),game.height());
    // animated gradient background
    drawBackground(dt);

    // draw asteroids
    for (const a of asteroids) a.draw(ctx);

    // draw heal pickups
    for (const hp of healPickups) hp.draw(ctx);

    // draw bullets
    for (const b of bullets) b.draw(ctx);

    // draw players
    p1.draw(ctx);
    p2.draw(ctx);

    // HUD overlay inside canvas (optional)
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.font = 'bold 14px sans-serif';
    ctx.fillStyle = '#fff';
    ctx.fillText(`P1 HP: ${Math.round(p1.health)}`, 14, game.height()-12);
    ctx.textAlign = 'right';
    ctx.fillText(`P2 HP: ${Math.round(p2.health)}`, game.width()-14, game.height()-12);
    ctx.restore();
  }

  // Controls for start / restart / pause
  function showCenter(title='Paused', text='', showStart=false){
    centerTitle.textContent = title;
    centerText.textContent = text;
    center.classList.add('show');
    if (showStart) startBtn.style.display = 'inline-block';
    else startBtn.style.display = 'none';
  }
  function hideCenter(){ center.classList.remove('show'); }

  startBtn.addEventListener('click', () => {
    audioCtx.resume().catch(()=>{});
    hideCenter();
    state.running = true;
    state.paused = false;
    lastTime = null;
    // initial call to resize stars
    makeStars(90);
  });

  restartBtn.addEventListener('click', () => {
    resetGame();
  });

  // Pause toggle
  window.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'p'){
      state.paused = !state.paused;
      if (state.paused) showCenter('Paused', 'Game is paused — press P to resume', false);
      else hideCenter();
    }
  });

  // Initial game setup and reset
  function resetGame(){
    // reset state
    state.running = false;
    state.paused = false;
    state.round = 1;
    roundEl.textContent = state.round;
    p1killsEl.textContent = 'Kills: 0';
    p2killsEl.textContent = 'Kills: 0';
    scoreBoardEl.textContent = '0 - 0';
    // reset containers
    bullets = []; healPickups = []; asteroids = [];
    // spawn players
    spawnPlayers();
    makeStars(90);
    spawnAsteroids(4);
    nextHealAt = now() + 3000;
    showCenter('Ready?', 'Press Start to begin', true);
  }

  // Kick things off
  resetGame();
  requestAnimationFrame(gameTick);

  // Ensure canvas resizes when container sizes change
  const ro = new ResizeObserver(()=>{
    resize();
    makeStars(90);
  });
  ro.observe(canvas);

  // Start immediately when page loads if user clicks start; else waiting.
  // Also allow spacebar to start
  window.addEventListener('keydown', (e) => {
    if (!state.running && (e.key === ' ' || e.key === 'Enter')) {
      startBtn.click();
    }
  });

  // Small friendly instructions shown in center at load
  showCenter('Two-Player Shooter', 'Player 1: WASD + F to shoot · G to heal (if collected)  \nPlayer 2: Arrows + L to shoot · ; to heal (if collected).  Press Start to play.', true);

  // Prevent accidental selection during play
  window.addEventListener('mousedown', (e)=> e.preventDefault());
})();
</script>
</body>
</html>
